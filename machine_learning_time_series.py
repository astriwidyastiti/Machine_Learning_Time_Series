# -*- coding: utf-8 -*-
"""Machine_Learning_Time_Series.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J3sAwYjz_SS3PFTCUnJ6YMNJ5hyRYFbH

*   Nama : Astri Widyastiti
*   email : astriwidyastiti@gmail.com
*   idDicoding : astriwidyastiti
"""

from google.colab import drive
drive.mount('/content/drive')

# Import library yang akan digunakan
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from keras.layers import Dense, LSTM
from sklearn.model_selection import train_test_split
import seaborn as sns

"""## EDA"""

# Load dataset
data=pd.read_csv('/content/drive/MyDrive/raw_sales.csv')
data.head()

# mengecheck informasi mengenai dataset
data.info()

# mengecheck jumlah dataset yang duplikat
data.duplicated().sum()

# mengubah tipe data pada kolom datesold
data['datesold']=pd.to_datetime(data['datesold'])
data.head()

# visualisasi harga rumah berdasarkan tanggal
dates = data['datesold'].values
price = data['price'].values

plt.figure(figsize=(15,5))
plt.plot(dates,price)
plt.title('Price',
          fontsize=20);

# visualisasi harga rumah berdasarkan tanggal dan bedrooms
fig, ax = plt.subplots(figsize=(20,5))
sns.scatterplot(data=data, x='datesold', y='price', hue='bedrooms',  ax=ax, palette='coolwarm')
ax.set(title='Harga Rumah Berdasarkan Jumlah Bedrooms')
ax.set_ylabel('Price')
ax.set_xlabel('Datesold')
plt.show()

# visualisasi harga rumah berdasarkan tanggal dan jenis property
fig, ax = plt.subplots(figsize=(20,5))
sns.scatterplot(data=data, x='datesold', y='price', hue='propertyType',  ax=ax, palette='coolwarm')
ax.set(title='Harga Rumah Berdasarkan Jenis Property')
ax.set_ylabel('Price')
ax.set_xlabel('Datesold')
plt.show()

# menghitung jumlah masing masing tipe property
data['propertyType'].value_counts()

# mengubah kategori tipe property
def change_property(x):
  if x=='house':
    return 0
  else:
    return 1
data['propertyType']=data['propertyType'].apply(change_property)
data.head()

"""## Preprocessing"""

# split data
from sklearn.model_selection import train_test_split
x = np.array(data[['postcode','propertyType','bedrooms']])
y = np.array(data[['price']])

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

x = scaler.fit_transform(x)
y = scaler.fit_transform(y)

xtrain, xtest, ytrain, ytest = train_test_split(x, y,
                                                test_size=0.2,
                                                random_state=42, shuffle=False)

jumlah_val=0.2*29580
print('20% dari jumlah data = ', jumlah_val)
print("Jumlah data untuk training (xtrain):", xtrain.shape[0])
print("Jumlah data untuk validasi (xtest):", xtest.shape[0])
print("Jumlah label untuk training (ytrain):", ytrain.shape[0])
print("Jumlah label untuk validasi (ytest):", ytest.shape[0])

"""## Modelling"""

# membuat model
from keras.models import Sequential
from keras.layers import Dense, LSTM, Dropout
model = Sequential()
model.add(LSTM(64, return_sequences=True,
               input_shape= (xtrain.shape[1], 1)))
model.add(Dense(48))
model.add(Dropout(0.5))
model.add(Dense(1, activation='sigmoid'))
model.summary()

# menentukan optimizer dan menerapkan learning rate
from keras.optimizers import Adam

optimizer = Adam(learning_rate=0.00001)

#Menghitung nilai mae
Mae = (y.max() - y.min()) * 0.1
print("Price Max= ",y.max())
print("Price Min= ",y.min())
print("MAE= ",Mae)

#Callback 10% mae
class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('mae')<0.09999999999999999 and logs.get('val_mae')<0.09999999999999999):
      print("MAE < 10% skala data")
      self.model.stop_training = True
callbacks = myCallback()

# training model
model.compile(loss=tf.keras.losses.Huber(),
              optimizer=optimizer,metrics=["mae"])
history = model.fit(xtrain,ytrain,epochs=100,batch_size=32,validation_data=(xtest,ytest),callbacks=[callbacks])

"""## Visualisasi Training dan Validation"""

# plot training dan validation data
plt.figure(figsize=(10, 5))

loss = history.history['loss']
val_loss = history.history['val_loss']
mae = history.history['mae']
val_mae = history.history['val_mae']

plt.subplot(1, 2, 1)
plt.plot(loss, label='Training Loss')
plt.plot(val_loss, label='Validation Loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(mae, label='Training MAE')
plt.plot(val_mae, label='Validation MAE')
plt.title('Training and Validation MAE')
plt.xlabel('Epochs')
plt.ylabel('MAE')
plt.legend()

plt.tight_layout()
plt.show()

# Nilai MAE
loss, mae = model.evaluate(xtest, ytest)
print(f'MAE: {mae}')